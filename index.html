<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GraphML Visualization with Animation</title>
  <!-- Include D3.js (v7 or higher). Adjust version/CDN as needed. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.2/d3.min.js"
          integrity="sha512-qJqY/WVUmqJ9OAbfCteOb1PtzqcLr0Uh9/QnBUZWUmGpG8lyHvVoTwxTr8hcRGH7qFhDIscB/HxcG3IIBK1xIA=="
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #controls {
      padding: 10px;
      background: #eee;
      border-bottom: 1px solid #ccc;
    }
    #fileInput {
      margin: 5px;
    }
    svg {
      width: 100vw;
      height: calc(100vh - 50px); /* adjust for the controls bar */
      background: #fafafa;
      display: block;
    }
    .node circle {
      cursor: pointer;
      stroke: #555;
      stroke-width: 1px;
    }
    .node text {
      font-size: 12px;
      pointer-events: none;
    }
    .link {
      stroke: #999;
      stroke-opacity: 0.6;
    }
  </style>
</head>
<body>

<div id="controls">
  <label for="fileInput">Upload GraphML file:</label>
  <input type="file" id="fileInput" accept=".graphml, .xml"/>
</div>

<svg id="graph"></svg>

<script>
// ---------------------------------------------------------------------------
// 1. File upload event:
//    When a user selects a file, we'll load it, parse it, and visualize.
// ---------------------------------------------------------------------------
document.getElementById('fileInput').addEventListener('change', event => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    const graphmlString = e.target.result;
    // Now we can parse the GraphML and visualize it
    visualizeGraphML(graphmlString);
  };
  reader.readAsText(file);
});

// ---------------------------------------------------------------------------
// 2. Core function: parse & visualize GraphML
// ---------------------------------------------------------------------------
function visualizeGraphML(graphmlText) {
  // Parse GraphML
  const { nodes, links } = parseGraphML(graphmlText);

  // Clear any previous SVG content
  svg.selectAll("*").remove();

  // We'll pick a "center node" to show first (e.g., the first node),
  // but you can choose by ID or any other logic
  const centerNode = nodes[0];
  let drawnNodes = [centerNode];
  let drawnLinks = [];

  // Render only the center node
  renderGraph(drawnNodes, drawnLinks);

  // After a short delay, twinkle the center node
  // then add the rest of the graph
  setTimeout(() => {
    twinkleNode(centerNode.id, 3, 300, () => {
      drawnNodes = nodes; // all nodes
      drawnLinks = links; // all edges
      renderGraph(drawnNodes, drawnLinks);
    });
  }, 1000);
}

// ---------------------------------------------------------------------------
// 3. Parse GraphML
//    You can adapt this to capture additional node/edge attributes.
// ---------------------------------------------------------------------------
function parseGraphML(graphmlText) {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(graphmlText, "application/xml");

  // Find the <graph> element
  const graphTag = xmlDoc.querySelector("graph");
  if (!graphTag) {
    console.error("No <graph> element found in GraphML.");
    return { nodes: [], links: [] };
  }

  // Extract <node> tags
  const nodeTags = graphTag.querySelectorAll("node");
  const nodes = [];
  nodeTags.forEach(node => {
    nodes.push({
      id: node.getAttribute("id")
      // Add more attributes here if needed:
      // data: parse additional <data> elements, etc.
    });
  });

  // Extract <edge> tags
  const edgeTags = graphTag.querySelectorAll("edge");
  const links = [];
  edgeTags.forEach(edge => {
    links.push({
      source: edge.getAttribute("source"),
      target: edge.getAttribute("target")
      // Add weight, keywords, etc. as needed
    });
  });

  return { nodes, links };
}

// ---------------------------------------------------------------------------
// 4. Setup global references for the SVG and its dimensions
//    We'll create them once, then update in renderGraph().
// ---------------------------------------------------------------------------
const svg = d3.select("#graph");
let width = window.innerWidth;
let height = window.innerHeight - 50; // subtract controls bar height

window.addEventListener("resize", () => {
  width = window.innerWidth;
  height = window.innerHeight - 50;
  svg.attr("width", width).attr("height", height);
});

const simulation = d3.forceSimulation()
  .force("link", d3.forceLink().id(d => d.id).distance(100))
  .force("charge", d3.forceManyBody().strength(-300))
  .force("center", d3.forceCenter(width / 2, (height / 2)));

// We'll create top-level groups for edges and nodes
const linkGroup = svg.append("g").attr("class", "links");
const nodeGroup = svg.append("g").attr("class", "nodes");

// ---------------------------------------------------------------------------
// 5. Render the graph (or subgraph) with animation
// ---------------------------------------------------------------------------
function renderGraph(renderNodes, renderLinks) {

  // 5.1. LINKS
  const linkSel = linkGroup.selectAll("line.link")
    .data(renderLinks, d => d.source + "-" + d.target);

  // Remove old links
  linkSel.exit().remove();

  // Add new links
  linkSel.enter()
    .append("line")
    .attr("class", "link")
    .attr("stroke-width", 2)
    .attr("opacity", 0)
    .transition()
    .duration(1000)
    .attr("opacity", 1);

  // 5.2. NODES
  const nodeSel = nodeGroup.selectAll(".node")
    .data(renderNodes, d => d.id);

  // Remove old nodes
  nodeSel.exit().remove();

  // Add new nodes
  const nodeEnter = nodeSel.enter()
    .append("g")
    .attr("class", "node");

  // Circle
  nodeEnter.append("circle")
    .attr("r", 0) // Start from radius 0 for a pop-in effect
    .style("fill", "#69b3a2")
    .transition()
    .duration(600)
    .attr("r", 15);

  // Optional text label
  nodeEnter.append("text")
    .attr("dx", 20)
    .attr("dy", ".35em")
    .text(d => d.id);

  // Merge the new nodes with existing for the force simulation
  nodeEnter.merge(nodeSel);

  // 5.3. Update force simulation
  simulation
    .nodes(renderNodes)
    .on("tick", ticked);

  simulation.force("link")
    .links(renderLinks);

  simulation.alpha(1).restart();

  function ticked() {
    linkGroup.selectAll(".link")
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    nodeGroup.selectAll(".node")
      .attr("transform", d => `translate(${d.x},${d.y})`);
  }
}

// ---------------------------------------------------------------------------
// 6. "Twinkle" animation for a given node
//    Repeatedly flashes the node circle color a few times.
// ---------------------------------------------------------------------------
function twinkleNode(nodeId, repetitions, interval, callback) {
  let count = 0;

  const blink = () => {
    const circle = svg.selectAll(".node")
      .filter(d => d.id === nodeId)
      .select("circle");

    // Animate fill color from normal to red, then back
    circle
      .transition()
      .duration(interval / 2)
      .style("fill", "#ff0000")
      .transition()
      .duration(interval / 2)
      .style("fill", "#69b3a2")
      .on("end", () => {
        count++;
        if (count < repetitions) {
          blink(); // keep blinking
        } else {
          if (callback) callback(); // done
        }
      });
  };

  blink();
}
</script>
</body>
</html>
